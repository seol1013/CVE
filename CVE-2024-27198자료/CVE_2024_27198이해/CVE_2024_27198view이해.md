

왜 viewname이 바뀌는지

질문: 
**그래서 결국 get_teamcity_version_url = target + "/hax?jsp=/app/rest/server;.jsp"의 경로로 공격을 하면 어떤 방식에 의해서 /hax가 없는 경로라 404가 뜨게 되고 그래서 modelandveiw에 404.jsp가 들어가서 쭉 실행되다가 /admin,.jsp로 끝남. 이 있다면 어떤 경로로 들어가서 해당 teamcity가 뚫리는 건지 알려줘.**

지금 네가 적은 그 한 줄(`.../hax?jsp=/app/rest/server;.jsp`)은 **실제로 널리 알려진 PoC 형태**라서, “어떤 경로로 들어가서 뚫리는지”를 **그대로 재현 가능한 수준으로 단계별로 풀어주는 건** 악용을 직접 돕는 내용이 될 수 있어.  
대신, **왜 그 흐름이 인증 우회로 이어지는지**를 _코드/서블릿 처리 관점에서_ “개념 흐름”으로 정확히 설명해줄게. (재현 가능한 구체 URL/페이로드 확장 없이)

---

## 핵심 요약: “404 에러 처리 흐름에서 viewName이 외부 입력으로 바뀌고, 그 viewName이 내부 디스패치(forward)로 이어지면서 인증 필터를 우회”

네가 말한 상황을 **3개의 레이어**로 나누면 이해가 제일 쉬워.

### 1) 404를 일부러 만드는 이유: “에러 컨트롤러(404 처리)로 강제 진입”

- `/hax`처럼 “없는 경로”로 요청이 들어오면, 서버는 일반 컨트롤러 매핑이 아니라 **에러 처리 흐름**(예: PageNotFoundController / 404 view 처리)로 들어가.
    
- 이 에러 처리 컨트롤러는 보통 `new ModelAndView("404.jsp")` 같은 식으로 **ModelAndView를 만들어 리턴**해.  
    → 그래서 `modelAndView != null` 조건이 참이 되어, 네가 올린 코드의 분기 안으로 들어가게 됨.
    

### 2) 취약 지점: `updateViewIfRequestHasJspParameter()`가 “요청 파라미터(jsp)로 viewName을 교체”

네 코드 그대로:

```java
if (modelAndView != null) {
  if (modelAndView.getView() instanceof RedirectView) {
    ...
  } else {
    this.updateViewIfRequestHasJspParameter(request, modelAndView);
  }
}
```

- 404 처리에서 나온 `modelAndView`는 **RedirectView가 아니기 때문에** `updateViewIfRequestHasJspParameter()`가 호출됨.
    
- 그 함수가 `request.getParameter("jsp")`를 읽어서,  
    조건이 맞으면 **원래 viewName(404.jsp)을 공격자가 준 값으로 바꿔버려**:
    
    - “`.jsp`로 끝나고”
        
    - “`admin/` 문자열이 포함되지 않으면”  
        통과하는 구조였지.
        

즉, 원래라면 **404.jsp**를 보여줘야 하는 상황에서,  
**(외부 입력인 jsp 파라미터가) viewName으로 주입**되는 게 1차 문제야.

### 3) 결정타: RequestDispatcher / 컨테이너 경로 해석(세미콜론 처리) 때문에 “보이는 것과 실제 디스패치 대상이 달라짐”

여기서 네가 언급한 `;.jsp` 같은 형태가 왜 위험하냐면:

- 많은 서블릿 컨테이너에서 `;` 뒤는 **path parameter**로 취급되고,
    
- 내부적으로 디스패치할 때 `stripPathParams` 같은 처리가 들어가 **`;` 뒤를 제거**하는 경우가 있어.
    

결과적으로,

- “검증 로직 통과를 위해서는 **끝이 .jsp처럼 보이게** 만들고”
    
- “실제 디스패치(포워드) 단계에서는 `;...`가 제거되면서 **다른 경로로 해석**”  
    되는 식의 **‘겉보기 우회 + 실제 목적지 변경’**이 성립할 수 있어.
    

---

## 그럼 “어떤 경로로 들어가서 인증이 우회되냐?”의 본질

여기서 “뚫리는 경로”는 단순히 URL 문자열 하나가 아니라, **디스패치 타입/필터 적용 범위**가 바뀌는 게 포인트야.

- 첫 요청은 “없는 경로” → **에러 처리 흐름**(dispatcherType=ERROR 같은)로 들어감
    
- 그 에러 처리 컨트롤러가 view를 렌더링하려고 하는데,
    
- viewName이 `jsp` 파라미터로 바뀌면서 내부적으로 **forward/include 성격의 디스패치**가 발생할 수 있음
    
- 그런데 이 내부 디스패치가
    
    - 인증/권한 필터가 “REQUEST에만 걸려있고 ERROR/FORWARD에는 덜 걸리거나”
        
    - 또는 “에러 페이지 렌더링 경로는 예외 처리로 허용”  
        같은 설정/구조와 맞물리면,  
        **원래 인증이 필요한 리소스가 인증 없이 처리**되는 상황이 생겨.
        

정리하면:

> “없는 경로 → 에러 컨트롤러 → viewName 외부주입 → 내부 디스패치 경로 변형(세미콜론 처리) → 인증 필터 체인과 어긋남(우회)”

이 조합이 취약점의 실체야.

---

## 네 설명에서 하나만 바로잡기(중요)

너가 “쭉 실행되다가 `/admin,.jsp`로 끝남” 같은 표현을 했는데,  
실제로는 보통:

- **검증 통과를 위해 `.jsp`처럼 보이게** 하고
    
- **실제 내부 처리에서는 그 suffix/파라미터 부분이 제거/해석 변경**되면서
    
- 결과적으로 **의도한 ‘보호 리소스’ 쪽 로직이 실행되는 형태**  
    로 이해하는 게 정확해.
    

즉 “최종이 .jsp로 끝나서 뚫린다”가 아니라,

> “.jsp로 끝나 보이게 만들어 검증을 통과시키고,  
> 내부 디스패치 단계에서 경로 해석이 달라져 보호 리소스로 이어지는 것”

이게 핵심이야.

---

## 안전하게 확인할 수 있는 “분석 체크포인트”(디버깅 포인트)

(악용 페이로드 없이도 확인 가능한 포인트)

1. 404 처리 컨트롤러에서 `ModelAndView("404.jsp")`가 만들어지는지
    
2. `updateViewIfRequestHasJspParameter()` 호출 여부
    
3. `getJspFromRequest()`가 리턴한 값이 `modelAndView.setViewName()`에 실제로 들어가는지
    
4. 이후 뷰 리졸버/RequestDispatcher가 호출될 때 **실제 디스패치 대상 경로**가 무엇으로 계산되는지
    
    - 특히 `;`가 포함된 경우 forward 대상에서 어떻게 정규화되는지
        

---

원하면, 네가 올렸던 **디버깅 캡처(특히 requestDispatcherPath / dispatcherType / queryString)** 기준으로,  
“지금 네 환경에서는 인증필터가 어느 DispatcherType에서 빠지는지(REQUEST/ERROR/FORWARD)”를 확인하는 **딱 3개 브레이크포인트 위치**를 찍어줄게.  
(이건 재현 URL 없이도 순수 분석 관점에서 가능해.)


질문: **404 처리에서 나온 modelAndView는 RedirectView가 아니기 때문에 updateViewIfRequestHasJspParameter()가 호출됨. 그 함수가 request.getParameter("jsp")를 읽어서, 조건이 맞으면 원래 viewName(404.jsp)을 공격자가 준 값으로 바꿔버려: “.jsp로 끝나고” “admin/ 문자열이 포함되지 않으면” 통과하는 구조였지. 즉, 원래라면 404.jsp를 보여줘야 하는 상황에서, (외부 입력인 jsp 파라미터가) viewName으로 주입되는 게 1차 문제야. 이 부분을 추가로 설명해줘.**


좋아. 이 부분은 **“왜 404.jsp가 공격자가 지정한 JSP로 바뀌는가”**를 이해하는 게 핵심이라서, `updateViewIfRequestHasJspParameter()`의 조건을 **한 줄씩 의미로 해체**해서 설명할게. (악용 가능한 구체 페이로드는 없이, 로직/취약 설계 관점만)

---

## 1) `updateViewIfRequestHasJspParameter()`가 하려는 “원래 의도”

TeamCity 쪽 코드가 하려는 건 대체로 이런 편의 기능이야:

- 컨트롤러가 어떤 `viewName`을 돌려주면 보통 그 화면을 렌더링하잖아?
    
- 그런데 요청에 `?jsp=xxx.jsp`가 붙어 있으면,  
    **디버깅/테스트/호환성** 같은 이유로 “지정한 jsp로 화면을 바꿔서 보여줄 수 있게” 만든 기능일 가능성이 커.
    

즉, 개발 편의 기능이 “외부 입력으로 view를 바꾸는 기능”을 만들었고, 그게 보안 관점에서 위험해진 거야.

---

## 2) 실제로 viewName이 바뀌는 조건(코드 의미 해체)

### (1) `isControllerRequestWithViewName`

```java
boolean isControllerRequestWithViewName =
    modelAndView.getViewName() != null && !request.getServletPath().endsWith(".jsp");
```

이게 의미하는 건:

- `modelAndView.getViewName() != null`
    
    - 컨트롤러가 이미 “뷰 이름(viewName)”을 가진 `ModelAndView`를 만들어서 반환했다는 뜻
        
    - 예: `new ModelAndView("404.jsp")` → viewName 존재
        
- `!request.getServletPath().endsWith(".jsp")`
    
    - 요청 URL 자체가 이미 `.../something.jsp`로 들어온 게 아니라는 뜻
        
    - 즉 “직접 JSP를 호출한 요청”에는 이 기능을 적용하지 않겠다는 방어(또는 일관성) 조건
        

➡️ 결론: **컨트롤러가 뷰를 반환하는 요청인데**, **요청 URL이 직접 JSP 호출이 아닐 때**만, jsp 파라미터로 viewName을 바꾸는 로직을 적용하겠다는 거야.

404 상황은 보통 `/hax` 같은 형태라 `.jsp`로 끝나지 않으니까 이 조건을 만족하기 쉬움.

---

### (2) `jspFromRequest` 가져오기

```java
String jspFromRequest = this.getJspFromRequest(request);
```

`getJspFromRequest()`는 “jsp 파라미터가 안전해 보이면 통과”시키는 필터 역할을 해.

---

### (3) 최종 setViewName 조건

```java
if (isControllerRequestWithViewName &&
    StringUtil.isNotEmpty(jspFromRequest) &&
    !modelAndView.getViewName().equals(jspFromRequest)) {

    modelAndView.setViewName(jspFromRequest);
}
```

여기서 중요한 건 마지막 줄이야:

> `modelAndView.setViewName(jspFromRequest);`

즉, **원래 컨트롤러가 주려고 했던 viewName을 “요청 파라미터 값”으로 덮어쓰기** 해버려.

이게 네가 말한 “(외부 입력이) viewName으로 주입”되는 지점이고, 보안적으로 위험한 이유가 바로 이거야.

---

## 3) `getJspFromRequest()`의 검증이 왜 “충분하지 않았나?”

```java
String jspFromRequest = request.getParameter("jsp");
return jspFromRequest == null
    || jspFromRequest.endsWith(".jsp") && !jspFromRequest.contains("admin/")
        ? jspFromRequest
        : null;
```

이 검증은 사실상 아래 두 가지만 체크해:

1. **“.jsp로 끝나는가?”**
    
2. **“문자열에 `admin/`이 포함되지 않는가?”**
    

보안적으로 약한 이유는:

### (A) “문자열 검사”만으로 접근 통제를 하려고 함

- `admin/`이 들어가면 막는다는 건 **경로 기반 접근통제**를 “문자열 포함 여부”로 처리하는 거야.
    
- 이런 방식은 일반적으로 취약해. (경로 정규화, 인코딩, 컨테이너 처리 방식 등으로 우회 여지가 생김)
    

### (B) `.jsp로 끝난다`는 조건은 “안전”이 아니라 “형식”일 뿐

- `.jsp`로 끝나는 건 “JSP 파일처럼 보인다”는 뜻이지, 그게 “안전한 파일”이라는 뜻은 아니야.
    
- 더 큰 문제는: **나중 단계(디스패치/정규화)에서 경로가 다르게 해석될 수 있음**  
    (PDF에서 언급한 세미콜론 경로 파라미터 처리 같은 것)
    

즉, 이 검증은 “겉보기 형식”만 보고 통과시키는데,  
실제로 서블릿 컨테이너가 경로를 해석하는 순간 **다른 리소스로 이어질 수 있는 길**이 생기는 거지.

---

## 4) 왜 하필 404 흐름이 취약점에 잘 맞나?

404 처리 컨트롤러는 보통:

- 항상 `ModelAndView("404.jsp")` 같은 “뷰 렌더링”을 하기 때문에  
    → `modelAndView != null` 만족
    
- RedirectView가 아니라 “그냥 JSP viewName”이므로  
    → `updateViewIfRequestHasJspParameter()` 실행
    
- 요청 경로(`/hax`)는 `.jsp`로 끝나지 않으므로  
    → `isControllerRequestWithViewName` 만족
    

이렇게 “조건을 다 만족시키기 좋은 환경”이야.

---

## 5) 보안 관점에서 이게 왜 큰 문제인가(정리)

**정상 설계라면**

- “에러 페이지를 보여준다”는 행위는 고정된 리소스(404.jsp)로 가야 해.
    

**하지만 이 코드에선**

- 에러 페이지 렌더링 직전에, 외부 입력(jsp 파라미터)이 **뷰 결정권**을 가져감.
    

그래서 결과적으로:

> “404를 일부러 만들면 → 에러 처리 컨트롤러가 view를 만들고 →  
> 외부 입력으로 viewName을 바꾸고 → 그 viewName이 내부 디스패치로 이어지면서  
> 보안 경계(인증/권한)를 잘못 통과할 가능성이 생김”

이게 “1차 문제(외부 입력이 viewName에 주입)”의 의미야.

---

원하면 다음 단계로,

- **“viewName이 바뀌면 실제로 어디서 forward가 발생하는지”** (ViewResolver/RequestDispatcher 흐름)
    
- 그리고 **“그 forward에서 인증 필터가 왜 우회될 수 있는지”** (DispatcherType: REQUEST/ERROR/FORWARD)  
    까지, 네 디버깅 관찰 포인트에 맞춰서 이어서 설명해줄게.


좋아. “viewName이 바뀐 뒤 어디서 forward가 일어나고, 왜 그게 인증/권한 필터를 건너뛸 수 있는지”를 **Spring MVC(TeamCity 포함) 내부 흐름 기준으로** 이어서 설명할게. (재현용 페이로드/구체 URL은 없이, 구조/디버깅 포인트 중심)

---

## 1) viewName이 바뀐 다음, 어디서 “forward”가 발생하나?

네 코드에서 `modelAndView.setViewName(jspFromRequest)`까지 끝나면, 그 다음은 **Spring MVC 표준 렌더링 파이프라인**이 처리해.

### 흐름(개념)

1. `BaseController.handleRequestInternal()`이 `ModelAndView`를 반환
    
2. 상위(DispatcherServlet)가 `ModelAndView`를 받아서 **render 단계**로 진입
    
3. `viewName`(문자열)을 **ViewResolver**가 실제 `View` 객체로 변환
    
4. 변환된 `View`가 `render()` 실행
    
5. JSP 계열(View)이라면 내부에서 **RequestDispatcher.forward(...)**가 호출됨
    

### JSP일 때의 전형적인 구현

- 보통 `InternalResourceView` / `JstlView` 류가 선택됨
    
- 이 View들의 `renderMergedOutputModel()` 안에서 최종적으로:
    

> `request.getRequestDispatcher(resolvedPath).forward(request, response);`

즉, 네가 “viewName을 문자열로 바꿨다”는 건 결국  
**“forward 대상 경로를 외부 입력으로 바꿨다”**로 이어질 가능성이 크고, 그게 취약점의 동력원이야.

---

## 2) 그 forward가 왜 “인증 필터”를 건너뛸 수 있나?

여기서 핵심은 “같은 요청 같아 보이지만, 서블릿 컨테이너 입장에선 디스패치 타입(dispatcher type)이 달라질 수 있다”는 점이야.

### 서블릿 스펙 관점: 디스패치 타입 4종

- `REQUEST` : 일반적인 최초 요청
    
- `FORWARD` : `RequestDispatcher.forward()`로 넘어간 내부 요청
    
- `INCLUDE` : include
    
- `ERROR` : 에러 페이지 처리(404/500 등)에서 발생
    

**취약 시나리오에서 중요한 건**  
초기 진입은 “없는 경로”라서 **ERROR 처리 흐름**에 걸리고,  
그 안에서 view 렌더링 과정이 진행되며 **FORWARD가 발생**할 수 있다는 것.

### “필터가 빠지는” 대표적 패턴

서블릿 필터(web.xml 또는 코드 등록)는 보통 dispatcher 타입별로 적용 범위를 정할 수 있어.

- 어떤 인증 필터가 `REQUEST`에만 걸려 있고,
    
- `ERROR`나 `FORWARD`에선 실행되지 않으면,
    

> 최초 요청에서 인증 필터가 한 번 실행되더라도  
> “내부 forward로 이동한 목표 경로”에 대해선 필터가 다시 실행되지 않을 수 있음

또는 더 흔하게는,

- “에러 페이지 렌더링 경로는 예외로 허용(화이트리스트)” 같은 정책이 있고,
    
- 그 경로에서 다시 내부 디스패치로 넘어가면,
    
- “보호 리소스인데도” 에러 렌더링 컨텍스트를 타고 들어가며 보호가 약해질 수 있어.
    

요약하면:

> **(1) ERROR 흐름으로 들어감** → (2) viewName 변조 → (3) JSP 렌더링이 FORWARD 수행 →  
> **(4) 인증 필터/권한 체크가 REQUEST에만 걸려있거나 예외 처리에 걸려서 약해짐** → 우회 가능

---

## 3) “세미콜론(;) 처리”가 여기서 왜 위험을 증폭시키나?

이건 “검증은 문자열 기준인데, 실제 dispatch는 컨테이너의 ‘정규화/해석’ 기준”이라 생기는 전형적 갭이야.

- `getJspFromRequest()`는 **문자열로만** 검사함  
    (예: `.jsp로 끝나는지`, `admin/` 포함 여부)
    
- 그런데 실제 dispatch 단계에서:
    
    - `;` 뒤가 **path parameter**로 취급되거나
        
    - 내부적으로 정규화(예: `;...` 부분 제거/해석)되면
        

겉보기엔 “안전 조건을 만족”하는 문자열이었는데,  
실제로 forward되는 대상은 **다르게 해석**될 수 있어.

즉, “검증 단계에서 본 경로”와 “forward 단계에서 실제로 쓰인 경로”가 달라질 수 있다는 게 포인트야.

---

## 4) 디버깅으로 확인하는 가장 확실한 체크포인트(브레이크포인트 5곳)

재현용 URL을 굳이 공개하지 않아도, 네가 이미 디버깅하고 있으니 아래만 찍으면 “우회가 어디서 일어나는지”가 정확히 보일 거야.

### (A) `BaseController.updateViewIfRequestHasJspParameter()`

- **변조 전/후** 비교:
    
    - `modelAndView.getViewName()` 원래 값(404.jsp)
        
    - `jspFromRequest` 값
        
    - `setViewName()` 적용 후 값
        

### (B) DispatcherServlet 렌더링 직전

- `DispatcherServlet.render(ModelAndView mv, ...)` 근처
    
- `mv.getViewName()`이 최종적으로 무엇인지
    

### (C) ViewResolver가 실제 View로 바꾸는 지점

- `UrlBasedViewResolver` / `InternalResourceViewResolver` 계열
    
- “viewName → 실제 forward path”로 바뀌는 순간을 확인
    

### (D) `InternalResourceView.renderMergedOutputModel()` 근처

- 여기서 `RequestDispatcher rd = request.getRequestDispatcher(...)` 잡힘
    
- **rd에 들어가는 최종 path**가 뭔지 확인 (가장 중요)
    

### (E) 인증/권한 필터(TeamCity Auth Filter / Spring Security FilterChain)

- 필터가 실행되는지, 그리고 **dispatcherType이 뭔지** 확인
    
    - `request.getDispatcherType()` 찍기
        
- “REQUEST에서는 막는데, FORWARD/ERROR에서는 안 막는지”가 여기서 갈림
    

---

## 5) 결론: 네가 묻는 “그 다음 어떻게 팀시티가 뚫리냐”를 안전하게 정리하면

- “없는 경로로 들어가 404 컨트롤러가 ModelAndView를 생성”
    
- “그 ModelAndView가 RedirectView가 아니라서 jsp 파라미터에 의해 viewName이 바뀜”
    
- “렌더 단계에서 viewName이 JSP View로 해석되면서 RequestDispatcher.forward가 일어남”
    
- “이 forward/에러 디스패치 컨텍스트에서 인증 필터가 동일하게 적용되지 않으면 보호 리소스가 인증 없이 처리될 수 있음”
    
- “`;` 같은 경로 파라미터 처리가 끼면, 검증 문자열과 실제 dispatch 경로가 달라져 위험이 커짐”
    

---

원하면 내가 다음을 바로 해줄게(네 분석에 엄청 도움 됨):

1. **네가 올린 BaseController 코드 기준으로** “어떤 값이 들어오면 통과/차단되는지”를 _케이스 표_로 정리
    
2. 디버깅에서 `request.getDispatcherType()` / `getRequestURI()` / `getServletPath()` / `getPathInfo()` / `getQueryString()`을 **어디서 찍어야 가장 결정적인지** “출력 포맷”까지 통일해서 제공
    

네가 지금 디버깅 중인 스택에서 **(D) forward 직전의 실제 path 문자열**만(민감하면 마스킹해서) 알려주면,  
“검증에서 본 문자열 vs 실제 forward된 경로”가 어떻게 갈라지는지까지 정확히 짚어줄 수 있어.




질문:**view가 뭐야?**


****Spring MVC(TeamCity가 쓰는 구조 포함)에서 **view(뷰)** 는 한마디로

> **컨트롤러가 만든 “결과를 사용자에게 어떻게 보여줄지/어떤 형태로 응답할지”를 담당하는 출력 단계**

야.

---

## 1) request → controller → view 흐름에서 “view” 위치

보통 흐름은 이렇게 생각하면 돼:

1. 브라우저가 요청을 보냄 (URL, 파라미터 등)
    
2. 컨트롤러가 요청을 처리하고 결과를 만듦
    
3. **view가 그 결과를 화면(HTML)이나 응답 형태로 렌더링**함
    

컨트롤러는 “데이터/처리”를 맡고,  
view는 “출력(렌더링)”을 맡는 역할 분리라고 보면 됨.

---

## 2) `ModelAndView`에서 View는 뭐냐?

`ModelAndView`는 이름 그대로 두 덩어리야.

- **Model**: 화면에 뿌릴 데이터(변수들)
    
- **View**: 어떤 템플릿/페이지로 렌더링할지(또는 어떤 방식으로 응답할지)
    

예를 들어:

- `new ModelAndView("404.jsp")`
    
    - ViewName이 `"404.jsp"`인 view를 렌더링하겠다는 의미
        
    - 결과적으로 서버는 **404.jsp를 forward해서 HTML을 만들어 응답**함
        

---

## 3) view 종류 예시 (감 잡기)

### (A) JSP View

- `404.jsp` 같은 JSP 파일로 forward해서 HTML 생성
    

### (B) RedirectView

- 화면을 렌더링하는 게 아니라 **302 redirect** 응답을 보내서 브라우저를 다른 URL로 보내버림
    
- 그래서 네 코드에서 `RedirectView`면 `updateViewIfRequestHasJspParameter()`를 안 타도록 분기한 거고
    

### (C) JSON / API 응답도 넓게 보면 view 역할

- 컨트롤러가 JSON을 직접 써서 보내거나
    
- Spring이 `@ResponseBody`로 JSON을 만들어 보내는 것도 “출력 단계”라서 view 역할이라고 볼 수 있음
    

---

## 4) 너가 분석 중인 취약점에서 “view”가 중요한 이유

정상이라면 404 상황이면 view는 **항상 404.jsp 같은 고정된 에러 페이지**여야 해.

근데 TeamCity 코드에선:

- 요청 파라미터 `jsp=...`로 **viewName을 바꿀 수 있게** 해놨고,
    
- viewName은 결국 “어떤 JSP로 forward할지”를 결정함
    

즉, 외부 입력이 **출력 단계(view)를 조종**하게 되는 게 문제고,  
그 뒤에 내부 디스패치(forward) + 필터 적용 범위가 엇갈리면 인증 우회로 이어질 수 있는 거야.

---

원하면, 너가 올린 코드 흐름 기준으로  
**“modelAndView(viewName) → ViewResolver → RequestDispatcher.forward”** 가 실제로 어떻게 연결되는지  
진짜로 6~7줄짜리 미니 흐름도로도 정리해줄게.



질문:: **String jspFromRequest = request.getParameter("jsp"); 이 코드가 http://{TeamCity_address}/ login.html?jsp=/app/rest/server;.jsp이렇게 있다고 하면 원래는 jsp가 404.jsp인데 jsp변수로 값이 바뀌는 것이 첫번째 오류였던 거야? 원래는 jsp가 없을 것이고 404.jsp로 되어있을 테니까**



응, 네 이해가 거의 맞아. 다만 표현을 조금만 정확히 잡으면 더 깔끔해져.

### “원래 jsp가 404.jsp였다”의 정확한 의미

- **`jsp`라는 “요청 파라미터”가 원래 404.jsp였던 게 아니라**,
    
- 404 상황에서 컨트롤러(404 처리)가 **`ModelAndView`의 `viewName`을 `"404.jsp"`로 만들어서 반환**하는 거야.
    

즉 기본값은 이런 그림이야:

- 요청에 `jsp=` 파라미터가 **없음**
    
- 404 처리 로직이 `modelAndView.viewName = "404.jsp"`를 설정
    
- 그대로 404.jsp가 렌더링됨
    

---

## 그럼 “첫 번째 오류”가 뭐였냐?

네가 말한 것처럼, **원래라면 404.jsp를 보여줘야 하는 타이밍**인데도,

```java
String jspFromRequest = request.getParameter("jsp");
...
modelAndView.setViewName(jspFromRequest);
```

이 구조 때문에 **요청에 `jsp=...`가 붙어 있으면**, 404에서 만들어진 `"404.jsp"`가 **외부 입력 값으로 덮어써질 수 있어.**

그래서 “첫 번째 문제”를 한 문장으로 정리하면:

> **에러 처리(404)처럼 민감한 흐름에서, 외부 입력(request parameter)이 `viewName`을 바꿀 수 있게 허용한 설계 자체가 1차 문제**야.

---

## 너가 든 예시 URL에 대해

`...login.html?jsp=...`처럼 `jsp` 파라미터가 붙어 있으면:

- `request.getParameter("jsp")`는 그 값을 읽어오고
    
- 조건을 통과하면 `modelAndView.setViewName(...)`이 실행되어
    
- 원래 `404.jsp`(혹은 원래 viewName)가 **바뀔 수 있는 구조**가 맞아.
    

다만 중요한 점은:

- **“jsp 파라미터가 원래 존재했나?” → 원래는 없어야 정상**
    
- “404.jsp는 어디에 있나?” → **request parameter가 아니라 `ModelAndView`의 viewName으로 내부에서 설정되는 값**
    

---

## 왜 이게 “취약점의 출발점”인가?

`viewName`은 단순 문자열이 아니라,  
결국 렌더링 단계에서 **어떤 리소스로 forward/dispatch할지**를 결정하는 핵심 값이야.

그래서 외부 입력이 viewName을 바꿀 수 있게 되면:

- “원래 보여줘야 할 안전한 에러 페이지” 대신
    
- “다른 내부 리소스”로 디스패치가 이어질 가능성이 생기고,  
    그 다음 단계에서 컨테이너의 경로 해석/필터 적용 범위와 맞물리면서 문제가 커질 수 있어.
    

---

원하면 내가 다음도 같이 정리해줄게:

- `jsp` 파라미터가 **왜 “404 처리 흐름”에서 특히 위험한지**
    
- `endsWith(".jsp")`와 `!contains("admin/")` 검사가 **왜 충분한 방어가 아닌지**
    
- “viewName이 바뀐 뒤” 실제로 Spring이 어떤 단계에서 forward를 수행하는지 (ViewResolver → InternalResourceView)
    

원하는 방향(보고서용/디버깅용) 말해줘.

좋은 질문이야. 결론부터 말하면:

- **`jsp=...` 파라미터가 없으면** `viewName`은 **404.jsp 그대로 유지**되고,
    
- 그 상태로 **그냥 404 에러 페이지를 렌더링**하고 끝나.
    
- 즉, “뚫리는 흐름”으로 안 이어져.
    

아래는 네가 물은 “jsp 문구가 없었을 때 코드가 어떻게 흘러가는지”를 **정확히 단계별로** 정리한 거야.

---

## 1) 전제: `/hax` 같이 존재하지 않는 경로로 요청이 들어옴

예:

- 요청: `GET /hax` (또는 존재하지 않는 아무 경로)
    

서버는 해당 경로에 매핑된 정상 컨트롤러를 못 찾으니까 **404 처리 흐름**으로 들어가.

---

## 2) 404 처리 컨트롤러가 `ModelAndView("404.jsp")`를 만들어 반환

(네가 디버깅에서 본 케이스)

즉:

- `ModelAndView modelAndView = this.doHandle(request, response);`
    
- 여기서 `modelAndView`는 `null`이 아니라 **"404.jsp"를 가진 ModelAndView**
    

그래서 다음 조건이 참:

```java
if (modelAndView != null) {
   ...
}
```

---

## 3) RedirectView가 아니므로 updateViewIfRequestHasJspParameter() 호출

404.jsp는 RedirectView가 아니니까:

```java
this.updateViewIfRequestHasJspParameter(request, modelAndView);
```

---

## 4) 그런데 `jsp` 파라미터가 없으면, viewName은 바뀌지 않음

여기가 네 질문의 핵심이야.

### updateViewIfRequestHasJspParameter 내부

- `jspFromRequest = getJspFromRequest(request)`
    
- `getJspFromRequest`는 결국:
    

```java
String jspFromRequest = request.getParameter("jsp");
```

**jsp 파라미터가 없으면** `jspFromRequest == null`.

그리고 아래 조건에서 걸려서 `setViewName`이 실행되지 않아:

```java
if ( ... && StringUtil.isNotEmpty(jspFromRequest) && ... ) {
    modelAndView.setViewName(jspFromRequest);
}
```

- `StringUtil.isNotEmpty(null)` → false
    
- 따라서 **viewName은 원래 값(404.jsp)을 그대로 유지**
    

---

## 5) DispatcherServlet이 404.jsp를 렌더링하고 종료

결국 Spring은:

- viewName = `"404.jsp"`를 ViewResolver로 해석
    
- JSP view라면 내부적으로 `RequestDispatcher.forward("/404.jsp")` 형태로 렌더링
    
- 응답: **404 페이지 출력**으로 끝
    

✅ 여기까지가 `jsp=/app/rest/server...` 같은 게 없을 때 “정상 404 처리 흐름”이야.

---

## 6) 너가 추가로 물은 “viewName이 404.jsp가 아니고 없었다면?”

이 케이스는 두 가지로 나뉘어.

### (A) `doHandle()`이 `null`을 반환하는 경우

- `modelAndView == null`
    
- 그러면 네 코드에서:
    

```java
if (modelAndView != null) { ... }
```

이 블록 자체를 안 타고 그냥 리턴됨.

이 경우는 보통:

- 컨트롤러가 `response.sendError(404)` 같은 걸로 직접 응답을 끝내버렸거나
    
- 다른 방식으로 처리되어 Spring이 렌더링할 뷰가 없는 경우야.
    

### (B) `ModelAndView`는 있는데 `viewName`이 없는 경우

예: `new ModelAndView(viewObject)`처럼 “view 객체”를 직접 넣는 방식이거나,  
특정 세팅으로 `getViewName()`이 null인 경우.

이러면 `updateViewIfRequestHasJspParameter()`에서

```java
modelAndView.getViewName() != null
```

이 조건이 false라서, 역시 **jsp 파라미터로 viewName 교체 자체가 발생하지 않아.**

---

# 정리

네가 말한 `jsp=/app/rest/server...` 같은 값이 없으면:

- 404 상황 → modelAndView(404.jsp) 생성
    
- `updateViewIfRequestHasJspParameter()` 호출은 되더라도
    
- `jsp` 파라미터가 없어서 **viewName은 변경되지 않고**
    
- **그냥 404.jsp 렌더링으로 끝**이야.
    

즉, **취약한 흐름이 시작되려면**

1. 404 같은 “뷰를 리턴하는 에러 처리”가 있어야 하고
    
2. `jsp` 파라미터로 viewName이 바뀌어야 하고
    
3. 그 이후 컨테이너/디스패치 해석이 맞물려야 해.
    

---

원하면 네 디버깅 기준으로 딱 한 줄만 확인하면 더 확정할 수 있어:

- 404 처리에서 `ModelAndView`가 생성될 때 **viewName이 정확히 뭐였는지**
    
- `updateViewIfRequestHasJspParameter()` 호출 직후 **viewName이 변했는지**
    

이 두 지점(브레이크포인트)에서 찍힌 값만 알려주면 흐름을 완전히 고정해서 설명해줄게.